--- a/ch_career_mode/gui.py
+++ b/ch_career_mode/gui.py
@@
         self.chk_artistlimit = QCheckBox("Max 1 per artist per tier")
         self.chk_artistlimit.setChecked(True)
+        self.spin_min_diff = QSpinBox()
+        self.spin_min_diff.setRange(1, 5)
+        saved_min_diff = int(self.settings.value("min_difficulty", 1)) if self.settings.contains("min_difficulty") else 1
+        self.spin_min_diff.setValue(max(1, min(5, saved_min_diff)))
 
         self.folder_status_indicator = QLabel()
         self.folder_status_indicator.setFixedSize(12, 12)
         self.folder_status_label = QLabel("(none)")
@@
         form.addRow(QLabel("Tiers:"), self.spin_tiers)
         form.addRow(QLabel("Songs per tier:"), self.spin_songs_per)
         form.addRow(self.chk_artistlimit)
         form.addRow(self.chk_longrule)
         form.addRow(self.chk_group_genre)
+        form.addRow(QLabel("Minimum Difficulty:"), self.spin_min_diff)
         form.addRow(QLabel("Theme:"), self.theme_combo)
         form.addRow(self.btn_auto, self.btn_export)
@@
         self.spin_tiers.valueChanged.connect(self._on_tier_count_changed)
         self.search_box.textChanged.connect(self._refresh_library_view)
         self.theme_combo.currentTextChanged.connect(self._on_theme_changed)
         self.chk_group_genre.stateChanged.connect(self._on_group_genre_changed)
+        self.spin_min_diff.valueChanged.connect(self._on_min_difficulty_changed)
 
     def _update_size_constraints(self) -> None:
         if hasattr(self, 'lib_list'):
             self.lib_list.setMinimumWidth(LIBRARY_MIN_WIDTH)
@@
     def _refresh_library_view(self) -> None:
         q = self.search_box.text().lower().strip()
+        min_diff = self.spin_min_diff.value() if hasattr(self, "spin_min_diff") else 1
         self.lib_list.clear()
         for s in sorted(self.library, key=lambda s: (s.score, s.name.lower())):
-            if q and q not in s.name.lower() and q not in s.artist.lower() and q not in s.charter.lower():
+            if (s.diff_guitar or 0) < min_diff:
+                continue
+            if q and q not in s.name.lower() and q not in s.artist.lower() and q not in s.charter.lower():
                 continue
             item = self._build_song_item(s)
             self.lib_list.addItem(item)
@@
     def auto_arrange(self) -> None:
         if not self.library:
             QMessageBox.warning(self, "No library", "Scan your library first.")
             return
         n_tiers = self.spin_tiers.value()
         songs_per = self.spin_songs_per.value()
         self._regenerate_tier_names(procedural_refresh=self._is_procedural_theme())
 
-        tiers = auto_tier(
-            self.library,
+        min_diff = self.spin_min_diff.value()
+        songs = [s for s in self.library if (s.diff_guitar or 0) >= min_diff]
+        if not songs:
+            QMessageBox.warning(self, "No songs meet criteria", "Lower the minimum difficulty or scan more songs.")
+            return
+
+        tiers = auto_tier(
+            songs,
             n_tiers,
             songs_per,
             enforce_artist_limit=self.chk_artistlimit.isChecked(),
             keep_very_long_out_of_first_two=self.chk_longrule.isChecked(),
             shuffle_seed=None,
             group_by_genre=self.chk_group_genre.isChecked(),
         )
@@
     def _handle_library_drop(self, tier_widget: TierList, songs: List[Song]) -> None:
         for song in songs:
+            if hasattr(self, "spin_min_diff") and (song.diff_guitar or 0) < self.spin_min_diff.value():
+                continue
             item = self._build_song_item(song)
             tier_widget.addItem(item)
         self._sync_tier_height(tier_widget)
         self._sync_all_tier_heights()
+
+    def _on_min_difficulty_changed(self, value: int) -> None:
+        if hasattr(self, "settings"):
+            self.settings.setValue("min_difficulty", value)
+        self._refresh_library_view()
